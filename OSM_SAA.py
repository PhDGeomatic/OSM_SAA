# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OSM_SAA
                                 A QGIS plugin
 OSM_SAA
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-09-01
        git sha              : $Format:%H$
        copyright            : (C) 2019 by PhDGeomatic
        email                : 
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QVariant, QProcess
from PyQt5.QtGui import QIcon, QColor, QFont, QPalette
from PyQt5.QtWidgets import QAction, QFileDialog, QTableWidgetItem, QPushButton, QToolButton, QComboBox, QCheckBox, QWidget, QHBoxLayout, QApplication, QMessageBox, QProgressDialog, QDialog, QVBoxLayout, QProgressBar

# Initialize Qt resources from file resources.py
from .resources import *

import subprocess

from qgis.core import QgsProject, QgsMapLayer, QgsWkbTypes, Qgis, QgsFields, QgsCoordinateReferenceSystem, QgsGeometry, QgsFeatureRequest, QgsProcessingUtils, QgsField, QgsFillSymbol, QgsMarkerSymbol, QgsVectorLayer, QgsFeature, QgsMessageLog, QgsVectorFileWriter, QgsSymbol, QgsSingleSymbolRenderer, QgsCoordinateTransform, QgsTask, QgsTaskManager, QgsApplication, QgsProcessingAlgRunnerTask, QgsProcessingContext, QgsProcessingFeedback, QgsTaskManager, QgsLayerTreeLayer
                       

from functools import partial
from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError

import os
import os.path
import string
import processing
import sys
from processing.tools import vector

from .Save_dialog import SaveDialog
from .Parameters_dialog import ParametersDialog
from .Dockwidget import Dockwidget
from .Converter import *

class OSM_SAA:
    """QGIS Plugin Implementation."""
    
    
    
    def initDefaultParameters(self):
    
        self.currentLayer1 = None
        self.currentLayer2 = None
        self.currentLayer3 = None
        
        self.lockedLayer1 = False
        self.lockedLayer2 = False
        self.lockedLayer3 = False

        self.zoomFactor = 30
        self.saveDialog = None
        self.parametersDialog = None
        self.numDigits = 3
        
        self.taskSuccessfullyCompleted = True
        self.outOfMemory = False
        
        self.resultLayer = None
        self.resultTable = None
        
        self.currentID = 1
        self.maxFeatureID = 0
        
        self.killedTask = False
        self.javaProcess = None
        self.wrongPoints = []
        
        self.currentDir = None
        
        self.debug = False    
        
        self.xmlTemplateQuery = \
            '<osm-script>' \
                '<union into=\"_\">' \
                    '<query into=\"_\" type=\"way\">' \
                        '<has-kv k=\"building\" modv=\"\" regv=\".\"/>' \
                        '<bbox-query s=\"ymin\" w=\"xmin\" n=\"ymax\" e=\"xmax\"/>' \
                    '</query>' \
                    '<query into=\"_\" type="relation">' \
                        '<has-kv k=\"building\" modv=\"\" regv=\".\"/>' \
                        '<bbox-query s=\"ymin\" w=\"xmin\" n=\"ymax\" e=\"xmax\"/>' \
                    '</query>' \
                '</union>' \
                '<union into=\"_\">' \
                    '<item from=\"_\" into=\"_\"/>' \
                    '<recurse from=\"_\" into=\"_\" type=\"down\"/>' \
                '</union>' \
                '<print e=\"\" from=\"_\" geometry=\"skeleton\" ids=\"yes\" limit=\"\" mode=\"body\" n=\"\" order=\"id\" s=\"\" w=\"\"/>' \
            '</osm-script>' 
        
        self.settings = QSettings('QGIS','QGIS3')
    
        paramOnDisk = self.settings.value('Plugin-OSM_SAA/parameters')
        
        if paramOnDisk is not None:
            self.parameters = paramOnDisk
        else:
            self.parameters={}
            self.parameters["param1"] = "None"
            self.parameters["param2"] = "10"
            self.parameters["param3"] = "6"
            self.parameters["param4"] = "12"
            self.parameters["param5"] = "0.1"
            self.parameters["param6"] = "15"
            self.parameters["param7"] = "10"
            
            windowsOS = sys.platform.startswith('win')
            if windowsOS:
                binJava = "C:/Program Files/Common Files/Oracle/Java/javapath/java.exe"
                if os.path.exists(binJava):
                    self.parameters["param8"] = binJava
                else:
                    binJava = "C:/Program Files (x86)/Common Files/Oracle/Java/javapath/java.exe"
                    if os.path.exists(binJava):
                        self.parameters["param8"] = binJava
                    else:
                        self.parameters["param8"] = "Unknown"
            else:
                binJava = "/usr/bin/java"
                if os.path.exists(binJava):
                    self.parameters["param8"] = binJava
                else:
                    self.parameters["param8"] = "Unknown"
                    
        osmDir = os.path.join(self.plugin_dir, "osm")        
        if not os.path.exists(osmDir):
            os.makedirs(osmDir)
            
        inputDir = os.path.join(self.plugin_dir, "input")        
        if not os.path.exists(inputDir):
            os.makedirs(inputDir)

        outputDir = os.path.join(self.plugin_dir, "output")        
        if not os.path.exists(outputDir):
            os.makedirs(outputDir)            

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'OSM_SAA_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&OSM_SAA')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'OSM_SAA')
        self.toolbar.setObjectName(u'OSM_SAA')

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('OSM_SAA', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)
        
        return action
        
    def buildQuery(self, extent_4326):
        xmlQuery = self.xmlTemplateQuery
        xmlQuery = xmlQuery.replace('xmin', str(extent_4326.xMinimum()))
        xmlQuery = xmlQuery.replace('xmax', str(extent_4326.xMaximum()))
        xmlQuery = xmlQuery.replace('ymin', str(extent_4326.yMinimum()))
        xmlQuery = xmlQuery.replace('ymax', str(extent_4326.yMaximum()))
        xmlQuery = xmlQuery.encode('utf-8')
        return xmlQuery
        
    def clickOnShowResults(self):
        self.loadLinksLayer()
        self.loadStatisticsTable()        
    
    def loadLinksLayer(self):
        if self.resultLayer:
            layers = QgsProject.instance().mapLayers().values()
            for layer in layers:
                if layer == self.resultLayer:
                    QMessageBox.critical(None, "INFO", "Layer already in the canvas")
                    return                
            QgsProject.instance().addMapLayer(self.resultLayer)            
        else:
            QMessageBox.critical(None, "INFO", "Links layer not available...")
        
    def loadStatisticsTable(self):
        if self.resultTable:
            layers = QgsProject.instance().mapLayers().values()
            for layer in layers:
                if layer == self.resultTable:
                    QMessageBox.critical(None, "INFO", "Statistics already in the canvas")
                    return
            QgsProject.instance().addMapLayer(self.resultTable)
        else:    
            QMessageBox.critical(None, "INFO", "Statistics table is not available...")
    
    def clickOnSetParameters(self):
        
        if self.parametersDialog == None:
            self.parametersDialog = ParametersDialog()
            
        self.parametersDialog.setParameters(self.parameters)
        self.parametersDialog.show()
        result = self.parametersDialog.exec_()
        if result:
            dialogParameters = self.parametersDialog.getParameters()
            self.parameters = dialogParameters
            self.settings.setValue('Plugin-OSM_SAA/parameters', self.parameters)
          


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/OSM_SAA/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'OSM_SAA'),
            callback=self.run,
            parent=self.iface.mainWindow())
            
        self.icon_lock = QIcon(':/plugins/OSM_SAA/images/lock.png')
        self.icon_unlock = QIcon(':/plugins/OSM_SAA/images/unlock.png')
        self.icon_download = QIcon(':/plugins/OSM_SAA/images/download.png')
        self.icon_new = QIcon(':/plugins/OSM_SAA/images/new.png')
        self.icon_on = QIcon(':/plugins/OSM_SAA/images/power-on.png')
        self.icon_off = QIcon(':/plugins/OSM_SAA/images/power-off.png')

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)
        
        try:
            QgsProject.instance().layersAdded.disconnect(self.layersAdded)
            QgsProject.instance().layersRemoved.disconnect(self.layersRemoved)
            QgsProject.instance().layersWillBeRemoved.disconnect(self.layersWillBeRemoved)      
        except:
            if self.debug:
                QgsMessageLog.logMessage("No previous events associated to the signals: layersAdded, layersRemoved, layersWillBeRemoved", "OSM_SAA")

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&OSM_SAA'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.dockwidget == None:

                self.dockwidget = Dockwidget()
                
                self.initDefaultParameters()
                
                self.dockwidget.button_LockLayer1.clicked.connect(self.clickOnLockLayer1)
                self.dockwidget.button_LockLayer2.clicked.connect(self.clickOnLockLayer2)
                self.dockwidget.button_LockLayer3.clicked.connect(self.clickOnLockLayer3)
                self.dockwidget.button_DownloadLayer2.clicked.connect(self.clickOnDownloadLayer2)
                self.dockwidget.button_CreateLayer3.clicked.connect(self.clickOnCreateLayer3)
                
                self.dockwidget.button_Run.clicked.connect(self.clickOnRunJava)
                self.dockwidget.button_Param.clicked.connect(self.clickOnSetParameters)
                self.dockwidget.button_Result.clicked.connect(self.clickOnShowResults)
                
                self.dockwidget.button_next.clicked.connect(self.clickOnNextButton)
                self.dockwidget.button_previous.clicked.connect(self.clickOnPreviousButton)
                self.dockwidget.button_validation.clicked.connect(self.clickOnEnableValidation)
                self.dockwidget.lineEdit_number.textChanged.connect(self.changedFeatureNumber)
                
                self.dockwidget.comboBox_Layer1.currentIndexChanged.connect(self.changedComboBoxLayer1)
                self.dockwidget.comboBox_Layer2.currentIndexChanged.connect(self.changedComboBoxLayer2)
                self.dockwidget.comboBox_Layer3.currentIndexChanged.connect(self.changedComboBoxLayer3)
                
                self.dockwidget.radioButton_1.toggled.connect(self.clickOnRadioButton)
                self.dockwidget.radioButton_2.toggled.connect(self.clickOnRadioButton)
                self.dockwidget.radioButton_3.toggled.connect(self.clickOnRadioButton)
                self.dockwidget.radioButton_4.toggled.connect(self.clickOnRadioButton)
                
            try:
                QgsProject.instance().layersAdded.disconnect(self.layersAdded)
                QgsProject.instance().layersRemoved.disconnect(self.layersRemoved)
                QgsProject.instance().layersWillBeRemoved.disconnect(self.layersWillBeRemoved)
            except:
                if self.debug:
                    QgsMessageLog.logMessage("No previous events associated to the signals: layersAdded, layersRemoved, layersWillBeRemoved", "OSM_SAA")   
            
            QgsProject.instance().layersAdded.connect(self.layersAdded)
            QgsProject.instance().layersRemoved.connect(self.layersRemoved)
            QgsProject.instance().layersWillBeRemoved.connect(self.layersWillBeRemoved)

            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
            
            self.updateAllComboBox()
            self.setValidationGUI(False)
            
            

    def clickOnRunJava(self):
    
        self.jarFile = os.path.join(self.plugin_dir, "jar", "libOSM_SSA.jar")
        if not os.path.exists(self.jarFile):
            if self.debug:
                QgsMessageLog.logMessage("Java library not found (" + self.jarFile + ")", "OSM_SAA")
            QMessageBox.critical(None, "INFO", "JAVA LIBRARY NOT FOUND")            
            return
    
        if not (self.currentLayer1 and self.lockedLayer1):
            QMessageBox.critical(None, "INFO", "The REFERENCE BUILDINGS LAYER IS NOT LOCKED")
            return

        if not (self.currentLayer2 and self.lockedLayer2):
            QMessageBox.critical(None, "INFO", "The OSM BUILDINGS LAYER IS NOT LOCKED")
            return

        if not (self.currentLayer3 and self.lockedLayer3):
            QMessageBox.critical(None, "INFO", "The HOMOLOGOUS POINTS LAYER IS NOT LOCKED")
            return
               
        numPoints = self.currentLayer3.featureCount();    
        if (numPoints < 5):
            QMessageBox.critical(None, "INFO", "Select at least 5 homologous points (selected: " +str(numPoints)+")")
            return
      
        self.preProcessing()
        
    def onCancelButton(self):
        if self.javaProcess:
            self.javaProcess.kill()
    
        if self.debug:
            QgsMessageLog.logMessage("Killing JAVA process...", "OSM_SAA")
        
        self.killedTask = True
        

    def startDownloadOSM(self, extent):
    
        self.progressDialog = QProgressDialog("Downloading OSM data...", 'Cancel', 0, 100)
        #self.progressDialog.setWindowModality(Qt.WindowModal)
        self.progressDialog.setWindowModality(Qt.ApplicationModal)
        self.progressDialog.show()
        self.progressDialog.canceled.connect(self.onCancelButton)
        self.progressDialog.setLabelText("Downloading OSM data...")
        self.progressDialog.setMinimum(0)
        self.progressDialog.setMaximum(0)
        self.progressDialog.setValue(0)
        
        epsg = self.iface.mapCanvas().mapSettings().destinationCrs().authid()
        crsSrc = QgsCoordinateReferenceSystem(epsg)
        crsDest = QgsCoordinateReferenceSystem(4326)
        coordinateTransformer = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())
        extent_4326 = coordinateTransformer.transform(extent)

        self.taskDownload = QgsTask.fromFunction('Downloading OSM data...', self.runDownloadOSM, on_finished=self.finishedDownloadOSM, extent = extent_4326)
        QgsApplication.taskManager().addTask(self.taskDownload)
        
    def runDownloadOSM(self, task, extent):
    
        self.killedTask = False
 
        if self.debug:
            QgsMessageLog.logMessage("Task download OSM data: start", "OSM_SAA")
        
        task.setProgress(50)
             
        postXML = self.buildQuery(extent)
        osmUrl = 'http://overpass-api.de/api/interpreter'
        req = Request(url=osmUrl, data=postXML, headers={'Content-Type': 'application/xml'})
        
        try:
            response = urlopen(req)
        except URLError as e:
            QMessageBox.critical(None, "INFO", 'URL Error: '+str(e.args) + '\nReason: '+str(e.reason), "OSM_SAA")
            QgsMessageLog.logMessage('URL Error: '+str(e.args) + '\nReason: '+str(e.reason), "OSM_SAA");
            return
        except HTTPError as e:
            QMessageBox.critical(None, "INFO", 'URL Error: '+str(e.args) + '\nReason: '+str(e.reason), "OSM_SAA")
            QgsMessageLog.logMessage('HTTP Error: '+str(e.args) + '\nReason: '+str(e.reason), "OSM_SAA");
            return
            
        osmFullFileName = os.path.join(self.plugin_dir, "osm", 'osmDownloaded.qml')
        
        if self.debug:
            QgsMessageLog.logMessage('Downloading to: ' + osmFullFileName, "OSM_SAA")

        local_file = open(osmFullFileName, 'wb')

        total_size = 0
        block_size = 1024*8
    
        while not self.killedTask:
            buffer = response.read(block_size)
            if not buffer:
                break

            try:
                local_file.write(buffer)
                size = len(buffer)/float(1000000)
                total_size += size
            except:
                local_file.close()
                QgsMessageLog.logMessage('ERROR in writing to: ' + osmFullFileName, "OSM_SAA")
                return

        local_file.close()                
        response.close()

        return True
        
    def finishedDownloadOSM(self, exception, result=None):
    
        if self.debug:
            QgsMessageLog.logMessage("Task download OSM data: stop", "OSM_SAA")
    
        if exception is None:
            if result:
                if not self.progressDialog.wasCanceled():
                
                    if self.outputFileName:
                        layername = "multipolygons"
    
                        osmFile4326 = os.path.join(self.plugin_dir, "osm", 'osmDownloaded.qml|layername=' + layername)
                        osmFile3857 = self.outputFileName
                        
                        parameter = {'INPUT': osmFile4326, 'TARGET_CRS': 'EPSG:3857', 'OUTPUT': osmFile3857}
                        
                        try:
                            processing.run("qgis:reprojectlayer", parameter)            
                            fileName = os.path.basename(osmFile3857)
                            name = os.path.splitext(fileName)[0]
                        
                            vectorLayer = QgsVectorLayer(osmFile3857, name, "ogr")
                            QgsProject.instance().addMapLayer(vectorLayer)
                        except Exception as e:
                            QgsMessageLog.logMessage("Error in qgis:reprojectlayer", "OSM_SAA");
                else:
                    if self.debug:
                        QgsMessageLog.logMessage("Task download OSM data: killed", "OSM_SAA")
        else:
            QgsMessageLog.logMessage("Task download OSM data expection: " + str(exception), "OSM_SAA")
            raise exception
        
        self.progressDialog.setMaximum(100)
        self.progressDialog.setValue(100)

    def preProcessing(self):
    
        self.killedTask = False
      
        self.progressDialog = QProgressDialog("Creating spatial indices...", 'Cancel', 0, 100)
        #self.progressDialog.setWindowModality(Qt.WindowModal)
        self.progressDialog.setWindowModality(Qt.ApplicationModal)
        self.progressDialog.show()
        self.progressDialog.canceled.connect(self.onCancelButton)
        
        self.dockwidget.button_Result.setEnabled(False)
        
        if not self.progressDialog.wasCanceled():
            self.startCreateSpatialIndices()
        else:
            self.progressDialog.setValue(100)
            if self.debug:
                QgsMessageLog.logMessage("Task create spatial index: killed", "OSM_SAA")

            
    def startCreateSpatialIndices(self):
              
        self.progressDialog.setLabelText("Creating spatial indices...")
        self.progressDialog.setValue(0)
        
        self.task0 = QgsTask.fromFunction('Create spatial indices...', self.runCreateSpatialIndices, on_finished=self.finishedCreateSpatialIndices)
        QgsApplication.taskManager().addTask(self.task0)
            
    def runCreateSpatialIndices(self, task):
        if self.debug:
            QgsMessageLog.logMessage("Task create spatial index: start", "OSM_SAA")
        self.progressDialog.setValue(25)
        self.currentLayer1.dataProvider().createSpatialIndex()
        task.setProgress(25)
        
        self.progressDialog.setValue(50)
        task.setProgress(50)
        self.currentLayer2.dataProvider().createSpatialIndex()

        
        self.progressDialog.setValue(75)
        task.setProgress(75)
        self.currentLayer3.dataProvider().createSpatialIndex()
        return True
        
    def finishedCreateSpatialIndices(self, exception, result=None):
        
        if self.debug:
            QgsMessageLog.logMessage("Task create spatial index: stop", "OSM_SAA")
      
        if exception is None:
            if result:
                if not self.progressDialog.wasCanceled():
                    self.startCheckHPoints()
                else:
                    if self.debug:
                        QgsMessageLog.logMessage("Task check homologous points: killed", "OSM_SAA")
                    self.progressDialog.setValue(100)
        else:
            QgsMessageLog.logMessage("Task create spatial index expection: " + str(exception), "OSM_SAA")
            raise exception       

    def startCheckHPoints(self):

        self.progressDialog.setLabelText("Checking homologous points...")
        self.progressDialog.setValue(0)
        
        self.task1 = QgsTask.fromFunction('Check homologous points...', self.runCheckHPointCoordinates, on_finished=self.finishedCheckHPointCoordinates)
        QgsApplication.taskManager().addTask(self.task1)            
                 
    def runCheckHPointCoordinates(self, task):
        if self.debug:
            QgsMessageLog.logMessage("Task check homologous points: start", "OSM_SAA")
        self.wrongPoints = []
        if self.currentLayer1 and self.currentLayer2 and self.currentLayer3:
            numFeatures = self.currentLayer3.featureCount()
            self.progressDialog.setMaximum(numFeatures)
            features = self.currentLayer3.getFeatures()
            cont = 0
            lines = getSingleLines(self.currentLayer3)
            for line in lines:            
                pointS = line[0]
                pointT = line[1]                       
                if not self.existsInPolygons(pointS, self.currentLayer2):
                    self.wrongPoints.append([pointS,'source'])
                if not self.existsInPolygons(pointT, self.currentLayer1):
                    self.wrongPoints.append([pointT,'target'])

                self.progressDialog.setValue(cont)
                task.setProgress(cont)
                cont = cont + 1
                if self.progressDialog.wasCanceled():
                    break
            self.progressDialog.setMaximum(100)
        return True

    def createPointsLayer(self, points, name):     
        pointLayer = QgsVectorLayer("Point?crs=epsg:3857", name, "memory")
        provider = pointLayer.dataProvider()
        provider.addAttributes([QgsField('type', QVariant.String)])
        pointLayer.updateFields()
        for point in points:
            feat = QgsFeature(pointLayer.fields())
            feat.setAttribute('type', point[1])
            feat.setGeometry(QgsGeometry.fromPointXY(point[0]))
            provider.addFeatures([feat])    
        return pointLayer    

    def finishedCheckHPointCoordinates(self, exception, result=None):
        
        if self.debug:
            QgsMessageLog.logMessage("Task check homologous points: stop", "OSM_SAA")
       
        if exception is None:
            if result:
                if self.debug:
                    QgsMessageLog.logMessage("Found " + str(len(self.wrongPoints)) + " wrong points", "OSM_SAA")
                layers = QgsProject.instance().mapLayers().values()
                for layer in layers:
                    if (layer.type() == QgsMapLayer.VectorLayer and layer.name() == "wrong points"):
                        QgsProject.instance().removeMapLayer(layer)
                
                if len(self.wrongPoints) == 0:
                    if not self.progressDialog.wasCanceled():
                        self.startPerProcessing()
                    else:
                        if self.debug:
                            QgsMessageLog.logMessage("Task pre-processing: killed", "OSM_SAA")
                        self.progressDialog.setValue(100)
                else:
                    self.progressDialog.setValue(100)                    
                    QMessageBox.critical(None, "INFO", "Some homologous points are not snapped to the features.\r\n Look at the 'wrong points' layer")
                 
                    pointsLayer = self.createPointsLayer(self.wrongPoints, "wrong points")
                    style = os.path.join(self.plugin_dir,"styles","WrongPoints.qml")
                    pointsLayer.loadNamedStyle(style)
                    QgsProject.instance().addMapLayer(pointsLayer)
                          
                    root = QgsProject.instance().layerTreeRoot()
                    for child in root.children():
                        if isinstance(child, QgsLayerTreeLayer):
                            if child.name() == "wrong points":
                                child.setCustomProperty("showFeatureCount", True)   
        else:
            QgsMessageLog.logMessage("Task check homologous points expection: " + str(exception), "OSM_SAA")
            raise exception
            
    def startPerProcessing(self):
        
        self.progressDialog.setLabelText("Pre processing...")
        self.progressDialog.setValue(0)
    
        self.task2 = QgsTask.fromFunction('Pre processing...', self.runInputConversionTask, on_finished=self.finishedInputConversion)
        QgsApplication.taskManager().addTask(self.task2)
          
    def runInputConversionTask(self, task):

        if self.debug:
            QgsMessageLog.logMessage("Task pre-processing: start", "OSM_SAA")
        
        self.progressDialog.setValue(25)
        task.setProgress(25)        
        fileName = os.path.join(self.plugin_dir, "input", "source.car")
        exportPolygons(self.currentLayer2, fileName, -1, self.numDigits)
               
        self.progressDialog.setValue(50)
        task.setProgress(50)
        fileName = os.path.join(self.plugin_dir, "input", "target.car")
        exportPolygons(self.currentLayer1, fileName, -1, self.numDigits)
        
        self.progressDialog.setValue(75)
        task.setProgress(75)        
        self.saveCoordinates(self.currentLayer3, self.numDigits)
 
        return True
        
    def finishedInputConversion(self, exception, result=None):
        
        if self.debug:
            QgsMessageLog.logMessage("Task pre-processing: stop", "OSM_SAA")
        
        self.progressDialog.setValue(99)        
      
        if exception is None:
            if result:
                if not self.progressDialog.wasCanceled():
                    self.startJavaProcess()
                else:
                    if self.debug:
                        QgsMessageLog.logMessage("Task processing: killed", "OSM_SAA")
                    self.progressDialog.setValue(100)
        else:
            QgsMessageLog.logMessage("Task pre-processing expection: " + str(exception), "OSM_SAA")
            raise exception        
    
    def startJavaProcess(self):
            self.progressDialog.setLabelText("Computing...")
            self.progressDialog.setValue(0)
            
            self.outOfMemory = False

            trasformazione =  self.parameters["param1"]
            tolleranzaAngolo =  self.parameters["param2"]
            distanzaMassima =  self.parameters["param3"]
            distanzaMinimaPuntoIsolato =  self.parameters["param4"]
            tolleranzaIdentici =  self.parameters["param5"]
            angoloMinimoSignificativo = self.parameters["param6"]
            numeroIterazioni = self.parameters["param7"]
            path = self.parameters["param8"]
            pluginPath = self.plugin_dir

            javaCmd = '"' + path + '"' + ' -jar -Xmx1024m '+ self.jarFile + ' ' + \
                str(pluginPath) + ' ' + \
                str(angoloMinimoSignificativo) + ' ' + \
                str(numeroIterazioni) + ' ' + \
                str(tolleranzaAngolo) + ' ' + \
                str(distanzaMassima) + ' ' + \
                str(distanzaMinimaPuntoIsolato) + ' ' + \
                str(tolleranzaIdentici) + ' ' + \
                str(trasformazione)
            
            if self.debug:
                QgsMessageLog.logMessage("QProcess: " + javaCmd, "OSM_SAA")
                
            process = QProcess()
            self.javaProcess = process        
            process.started.connect(self.startedJavaProcess)
            process.readyReadStandardOutput.connect(partial(self.dataReady, process))
            process.readyReadStandardError.connect(partial(self.dataErrorReady, process))
            process.finished.connect(self.finishedJavaProcess)
            self.taskSuccessfullyCompleted = True
            process.start(javaCmd)
    
    def startedJavaProcess(self):
        if self.debug:
            QgsMessageLog.logMessage("Task processing: start", "OSM_SAA")   

    def dataErrorReady(self, p):
        byteError = p.readAllStandardError()
        strError = str(byteError, 'utf-8').strip()
        if self.debug:
            QgsMessageLog.logMessage("Console: "+ strError, "OSM_SAA")
        
        if "OutOfMemoryError" in strError:
            self.taskSuccessfullyCompleted = False
            self.outOfMemory = True

    def dataReady(self, p):
        byteOutput = p.readAllStandardOutput()
        strOutput = str(byteOutput, 'utf-8').strip()
        if self.debug:
            QgsMessageLog.logMessage("Console: "+ strOutput, "OSM_SAA")       
        if strOutput.startswith("ERR_"):
            self.taskSuccessfullyCompleted = False
        else:
            try:          
                percentage = int(strOutput)
                if percentage == 100:
                    percentage = 99                
                self.progressDialog.setValue(percentage)
            except ValueError:
                pass
        
    def finishedJavaProcess(self):  
        if self.debug:
            QgsMessageLog.logMessage("Task processing: stop", "OSM_SAA")
     
        if self.outOfMemory:
            self.progressDialog.setValue(100)
            QMessageBox.critical(None, "INFO", "Out of memory\nPlease reduce the extension of the data to be processed")
            if self.debug:
                QgsMessageLog.logMessage("ERROR: Out of Memory", "OSM_SAA")      
        elif self.progressDialog.wasCanceled():
            self.progressDialog.setValue(100)
            QMessageBox.critical(None, "INFO", "Process interrupted by the user")
            if self.debug:
                QgsMessageLog.logMessage("Task post-processing: killed", "OSM_SAA")
        else:
            self.postProcessing()

    def getReleaseName(self, layerName):
        release = 1
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if layer.name().startswith(layerName):
                try:
                    release = int(layer.name().split("_")[1]) + 1  
                except ValueError:
                    QgsMessageLog.logMessage("Error in getting the release of the layer: " + layerName)
        return layerName + "_" + str(release)
    
    def postProcessing(self):
    
        if self.debug:
            QgsMessageLog.logMessage("Task post-processing: start", "OSM_SAA")
            
        self.progressDialog.setLabelText("Post processing...")
        self.progressDialog.setValue(0)
        
        self.progressDialog.setValue(33)
        
        geojsonFile = os.path.join(self.plugin_dir, "output", "links.geojson")
        if os.path.exists(geojsonFile):
            geojsonLayer = QgsVectorLayer(geojsonFile, "links", "ogr")
            layerName = self.getReleaseName("Links")
            self.resultLayer = convertToMemoryLayer(geojsonLayer, "LineString?crs=epsg:3857", layerName);
            self.resultLayer.dataProvider().createSpatialIndex()
            customStyle = os.path.join(self.plugin_dir,"styles","ArrowStyle.qml")
            self.resultLayer.loadNamedStyle(customStyle)
            
        self.progressDialog.setValue(66)
                      
        statisticsFileName = os.path.join(self.plugin_dir, "output", "statistics")
        if os.path.exists(statisticsFileName + ".csv"):
            uri = "file:///" + statisticsFileName + ".csv?delimiter=%s" % (";")
            tableLayer = QgsVectorLayer(uri, "Statistics", "delimitedtext")
            layerName = self.getReleaseName("Statistics")
            self.resultTable = convertToMemoryLayer(tableLayer, "NoGeometry?crs=epsg:3857", layerName);
            
        self.dockwidget.button_Result.setEnabled(True)
        
        if self.debug:
            QgsMessageLog.logMessage("Task post-processing: stop", "OSM_SAA")

        self.progressDialog.setValue(100) 

        reply = QMessageBox.question(self.iface.mainWindow(), 'Task completed', 'Show results?', QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.Yes:
            self.clickOnShowResults()        
    
    def zoomToFeature(self, id, layer):
        layer.selectByIds([id])
        selectedFeature = layer.selectedFeatures()[0]
        centroid = selectedFeature.geometry().centroid()
        bboxGeometry = selectedFeature.geometry().boundingBox()
        bboxGeometry.scale(50)
        canvas = self.iface.mapCanvas()
        canvas.zoomToFeatureExtent(bboxGeometry)
        layer.selectByIds([])
            
    def changedFeatureNumber(self):
        if self.dockwidget.button_validation.isChecked():
            inputText = self.dockwidget.lineEdit_number.text()
            try:
                num = int(inputText)
                if (num < self.rangeFeatureID[0]) or (num > self.rangeFeatureID[1]):
                    QMessageBox.critical(None, "INFO", "FID out of range")
                else:
                    if self.currentLayer3.getFeature(num).isValid():
                        self.currentID = num
                        self.zoomToFeature(self.currentID, self.currentLayer3)
                    else:
                        QMessageBox.critical(None, "INFO", "FID doesn't exist")
            except ValueError:
                QMessageBox.critical(None, "INFO", "Insert an integer number")

    def setValidationGUI(self, status):
        self.dockwidget.button_next.setEnabled(status)
        self.dockwidget.button_previous.setEnabled(status)
        self.dockwidget.lineEdit_number.setEnabled(status)
        self.dockwidget.radioButton_1.setEnabled(status)
        self.dockwidget.radioButton_2.setEnabled(status)
        self.dockwidget.radioButton_3.setEnabled(status)
        self.dockwidget.radioButton_4.setEnabled(status)
        
        if status:
            self.loadValidation(self.currentLayer3)
            
            if self.currentID < self.rangeFeatureID[0]:
                self.currentID = self.rangeFeatureID[0]
                
            if self.currentID > self.rangeFeatureID[1]:
                self.currentID = self.rangeFeatureID[1]    
            
            self.dockwidget.lineEdit_number.setText(str(self.currentID))
            self.dockwidget.button_validation.setIcon(self.icon_on)
        else:
            self.dockwidget.lineEdit_number.setText("")
            self.dockwidget.label_total.setText("[]")
            self.dockwidget.button_validation.setIcon(self.icon_off)
            
    def getMinMaxFeatureID(self, layer):        
        min = sys.maxsize
        max = 0
        if layer:
            features = layer.getFeatures()
            for feature in features:
                fid = feature.id()
                if fid > max:
                    max = fid  
                if fid < min:
                    min = fid
        return [min,max]
                      
    def clickOnEnableValidation(self):
        if self.currentLayer3 and self.lockedLayer3:

            if not self.currentLayer3.isEditable():
                if self.dockwidget.button_validation.isChecked():
                    numberOfFeature = self.currentLayer3.featureCount()
                    self.rangeFeatureID = self.getMinMaxFeatureID(self.currentLayer3)
                    if numberOfFeature > 0:
                        self.setValidationGUI(True)
                        self.dockwidget.label_total.setText("[" + str(self.rangeFeatureID[1]) + "]")
                    else:
                        QMessageBox.critical(None, "INFO", "No features in layer " + self.currentLayer3.name())
                        self.setValidationGUI(False)
                        self.dockwidget.label_total.setText("[0]")
                        self.dockwidget.button_validation.setChecked(False)
                else:
                    self.setValidationGUI(False)
            else:
                QMessageBox.critical(None, "INFO", "The layer3 is in editing mode...")
                self.dockwidget.button_validation.setChecked(False)
                
        else:
            QMessageBox.critical(None, "INFO", "The layer3 must be locked!")
            self.dockwidget.button_validation.setChecked(False)

    def clickOnNextButton(self):
        self.currentID = self.currentID + 1
        while not self.currentLayer3.getFeature(self.currentID).isValid():
            self.currentID = self.currentID + 1
            if self.currentID >= self.rangeFeatureID[1]:
                self.currentID = self.rangeFeatureID[0]
        self.dockwidget.lineEdit_number.textChanged.disconnect(self.changedFeatureNumber)
        self.dockwidget.lineEdit_number.setText(str(self.currentID))
        self.dockwidget.lineEdit_number.textChanged.connect(self.changedFeatureNumber)
        self.zoomToFeature(self.currentID, self.currentLayer3) 
        self.updateRadioButton()
        
    def clickOnPreviousButton(self):
        self.currentID = self.currentID - 1
        while not self.currentLayer3.getFeature(self.currentID).isValid():
            self.currentID = self.currentID - 1           
            if self.currentID <= self.rangeFeatureID[0]:
                self.currentID = self.rangeFeatureID[1]
        self.dockwidget.lineEdit_number.textChanged.disconnect(self.changedFeatureNumber)
        self.dockwidget.lineEdit_number.setText(str(self.currentID))
        self.dockwidget.lineEdit_number.textChanged.connect(self.changedFeatureNumber)
        self.zoomToFeature(self.currentID, self.currentLayer3)
        self.updateRadioButton()
        
    def updateRadioButton(self):
        try:
            self.dockwidget.radioButton_1.toggled.disconnect(self.clickOnRadioButton)
            self.dockwidget.radioButton_2.toggled.disconnect(self.clickOnRadioButton)
            self.dockwidget.radioButton_3.toggled.disconnect(self.clickOnRadioButton)
            self.dockwidget.radioButton_4.toggled.disconnect(self.clickOnRadioButton)
        except:
            QgsMessageLog.logMessage("Error in disconnecting functions to the toggled radioButton signal", "OSM_SAA")

        field_index = self.currentLayer3.fields().indexFromName('quality')
        if (field_index != -1):
            feature = self.currentLayer3.getFeature(self.currentID)
            if feature.isValid():
                status = feature[field_index]
                if status == 'null':
                    self.dockwidget.radioButton_1.setChecked(True)
                elif status == 'correct':
                    self.dockwidget.radioButton_2.setChecked(True)
                elif status == 'wrong':
                    self.dockwidget.radioButton_3.setChecked(True)
                elif status == 'uncertain':
                    self.dockwidget.radioButton_4.setChecked(True)
                else:
                    self.dockwidget.radioButton_1.setChecked(True)
        
        try:        
            self.dockwidget.radioButton_1.toggled.connect(self.clickOnRadioButton)
            self.dockwidget.radioButton_2.toggled.connect(self.clickOnRadioButton)
            self.dockwidget.radioButton_3.toggled.connect(self.clickOnRadioButton)
            self.dockwidget.radioButton_4.toggled.connect(self.clickOnRadioButton)
        except:
            QgsMessageLog.logMessage("Error in connecting functions to the toggled radioButton signal", "OSM_SAA")
            
    def clickOnLockLayer1(self):
    
        if not self.currentLayer1:
            if self.dockwidget.comboBox_Layer1.count() > 0:
                index = self.dockwidget.comboBox_Layer1.currentIndex()
                self.currentLayer1 = self.dockwidget.comboBox_Layer1.itemData(index)
                
        if self.currentLayer1:
            layer = self.currentLayer1
            if layer.crs().authid() == 'EPSG:3857':      
                
                numberOfFeatures = layer.featureCount()
                if numberOfFeatures > 0:
                
                    originalStyle = os.path.join(self.plugin_dir, "styles", "Layer1.qml")

                    if not self.lockedLayer1: 
                        if (self.currentLayer1 == self.currentLayer2) and self.lockedLayer2:
                            QMessageBox.critical(None, "INFO", "Layer already LOCKED")
                            self.dockwidget.button_LockLayer1.setChecked(False)
                        else:
                            layer.saveNamedStyle(originalStyle)
                            myColour = QColor('#FF0000')
                            myOpacity = 0.5
                            mySymbol = QgsSymbol.defaultSymbol(layer.geometryType())
                            mySymbol.setColor(myColour)
                            mySymbol.setOpacity(myOpacity)
                            myRenderer = QgsSingleSymbolRenderer(mySymbol)
                            
                            layer.setRenderer(myRenderer)
                            self.dockwidget.comboBox_Layer1.setEnabled(False)
                            self.lockedLayer1 = True
                            self.dockwidget.button_LockLayer1.setIcon(self.icon_lock)
                    else:
                        layer.loadNamedStyle(originalStyle)
                        self.lockedLayer1 = False
                        self.dockwidget.comboBox_Layer1.setEnabled(True)
                        self.dockwidget.button_LockLayer1.setIcon(self.icon_unlock)
                else:
                    self.lockedLayer1 = False
                    self.dockwidget.button_LockLayer1.setChecked(False)
                    QMessageBox.critical(None, "INFO", "No features in layer "+layer.name())
                    
                layer.triggerRepaint()
                
            else:
                self.lockedLayer1 = False
                self.dockwidget.button_LockLayer1.setChecked(False)
                QMessageBox.critical(None, "INFO", "The Coordinate Reference System of the layer must be EPSG:3857")
        
        self.checkAllLayerLocked()
            
    
    def clickOnLockLayer2(self):
    
        if not self.currentLayer2:
            if self.dockwidget.comboBox_Layer2.count() > 0:
                index = self.dockwidget.comboBox_Layer2.currentIndex()
                self.currentLayer2 = self.dockwidget.comboBox_Layer2.itemData(index)   
        
        if self.currentLayer2:
            layer = self.currentLayer2
            if layer.crs().authid() == 'EPSG:3857':
                numberOfFeatures = layer.featureCount()
                if numberOfFeatures > 0:
                
                    originalStyle = os.path.join(self.plugin_dir, "styles", "Layer2.qml")
                    
                    if not self.lockedLayer2:
                        if (self.currentLayer1 == self.currentLayer2) and self.lockedLayer1:
                            QMessageBox.critical(None, "INFO", "Layer already LOCKED")
                            self.dockwidget.button_LockLayer2.setChecked(False)
                        else:
                            layer.saveNamedStyle(originalStyle)
                            myColour = QColor('#00FF00')
                            myOpacity = 0.5
                            mySymbol = QgsSymbol.defaultSymbol(layer.geometryType())
                            mySymbol.setColor(myColour)
                            mySymbol.setOpacity(myOpacity)
                            myRenderer = QgsSingleSymbolRenderer(mySymbol)
                            
                            layer.setRenderer(myRenderer)
                            self.lockedLayer2 = True
                            self.dockwidget.comboBox_Layer2.setEnabled(False)
                            self.dockwidget.button_DownloadLayer2.setEnabled(False)
                            self.dockwidget.button_LockLayer2.setIcon(self.icon_lock)
                    else:
                        layer.loadNamedStyle(originalStyle)
                        self.lockedLayer2 = False
                        self.dockwidget.comboBox_Layer2.setEnabled(True)
                        self.dockwidget.button_DownloadLayer2.setEnabled(True)
                        self.dockwidget.button_LockLayer2.setIcon(self.icon_unlock)
                        
                else:
                    self.lockedLayer2 = False
                    self.dockwidget.button_LockLayer2.setChecked(False)
                    QMessageBox.critical(None, "INFO", "No features in layer "+layer.name())
                    
                layer.triggerRepaint()
                
            else:
                self.lockedLayer2 = False
                self.dockwidget.button_LockLayer2.setChecked(False)
                QMessageBox.critical(None, "INFO", "The Coordinate Reference System of the layer must be EPSG:3857")
        
        self.checkAllLayerLocked()

            
    def clickOnLockLayer3(self):
    
        if not self.currentLayer3:
            if self.dockwidget.comboBox_Layer3.count() > 0:
                index = self.dockwidget.comboBox_Layer3.currentIndex()
                self.currentLayer3 = self.dockwidget.comboBox_Layer3.itemData(index)
    
        if self.currentLayer3:
            layer = self.currentLayer3
            if layer.crs().authid() == 'EPSG:3857':

                originalStyle = os.path.join(self.plugin_dir, "styles", "Layer3.qml")
                customStyle = os.path.join(self.plugin_dir,"styles","ArrowStyle.qml")
            
                if not self.lockedLayer3:
                    layer.saveNamedStyle(originalStyle)
                    layer.loadNamedStyle(customStyle)
                    
                    self.lockedLayer3 = True
                    self.rangeFeatureID = self.getMinMaxFeatureID(self.currentLayer3)[1]
                    
                    self.dockwidget.comboBox_Layer3.setEnabled(False)
                    self.dockwidget.button_LockLayer3.setIcon(self.icon_lock)
                    self.dockwidget.button_CreateLayer3.setEnabled(False)
                    self.dockwidget.button_validation.setEnabled(True)
                else:
                    layer.loadNamedStyle(originalStyle)
                    
                    self.lockedLayer3 = False
                    self.rangeFeatureID = [0,0]
                    
                    self.dockwidget.comboBox_Layer3.setEnabled(True)
                    self.dockwidget.button_LockLayer3.setIcon(self.icon_unlock)
                    self.dockwidget.button_CreateLayer3.setEnabled(True)
                    
                    
                    self.dockwidget.button_validation.setEnabled(False)
                    self.dockwidget.button_validation.setChecked(False)
                    self.setValidationGUI(False)
                    
                layer.triggerRepaint()
                
            else:
                self.lockedLayer3 = False
                self.dockwidget.button_LockLayer3.setChecked(False)
                QMessageBox.critical(None, "INFO", "The Coordinate Reference System of the layer must be EPSG:3857")
  
        self.checkAllLayerLocked()
        
    def checkAllLayerLocked(self):    
        if self.lockedLayer1 and self.lockedLayer2 and self.lockedLayer3:
            self.dockwidget.button_Run.setEnabled(True)
        else:
            self.dockwidget.button_Run.setEnabled(False)
        
    def clickOnDownloadLayer2(self): 
        layers = QgsProject.instance().mapLayers().values()
        if self.saveDialog == None:
            self.saveDialog = SaveDialog(self.iface, layers, self.currentDir)
        self.saveDialog.show()
        result = self.saveDialog.exec_()
        if result:
            downloadExtent = self.saveDialog.downloadExtent
            self.outputFileName = self.saveDialog.fullFileName   
            if self.outputFileName:
                self.startDownloadOSM(downloadExtent)
        
    def clickOnCreateLayer3(self):
        type = QgsWkbTypes.LineString
        fullFileName, filter_string = QFileDialog.getSaveFileName(None, "Select output file ",self.currentDir, '*.shp')
        if (fullFileName != ""):
            self.currentDir = os.path.dirname(fullFileName)
            if not fullFileName.endswith(".shp"):
                fullFileName = fullFileName + ".shp"
            layer = self.creaLayer(fullFileName, type)
            if layer:
                self.updateComboBox(self.dockwidget.comboBox_Layer3, self.dockwidget.button_LockLayer3, QgsWkbTypes.LineGeometry, layer.name())
                style = os.path.join(self.plugin_dir, "styles","ArrowStyle.qml")
            
    def loadLayer(self, geomType):
        filter = "shp(*.shp)"
        layer = None
        fullFileName, filter_string  = QFileDialog.getOpenFileName(None, "Select input file ",self.currentDir, filter)
        if (fullFileName != ""):
            self.currentDir = os.path.dirname(fullFileName)
            name = os.path.basename(fullFileName)
            nameWithoutExt = os.path.splitext(name)[0]
            layer = QgsVectorLayer(fullFileName, nameWithoutExt, "ogr")
            if (layer.type() == QgsMapLayer.VectorLayer) and (layer.geometryType() == geomType):
                QgsProject.instance().addMapLayer(layer)
            else:
                strGeomType = self.getGeometryTypeAsString(geomType)
                QMessageBox.critical(None, "INFO", "The layer " + name + " is not of type: " + strGeomType)
        return layer
        
        
    def existsInPolygons(self, point, layer):
        pointGeom = QgsGeometry.fromPointXY(point)
        if layer:
            intersectPolygons = layer.getFeatures(QgsFeatureRequest().setFilterRect(pointGeom.buffer(1,2).boundingBox()))
            for polygon in intersectPolygons:
                points = polygonToPoints(polygon)
                for p in points:
                    if (abs(point.x() - p.x()) < 0.001) and (abs(point.y() - p.y()) < 0.001):
                        return True
        return False

    def saveCoordinates(self, layer, numDigit):
        if layer:
            coordSourceFile = os.path.join(self.plugin_dir, "input", "source.omo")
            coordTargetFile = os.path.join(self.plugin_dir, "input", "target.omo")
            fileS = open(coordSourceFile, 'w')
            fileT = open(coordTargetFile, 'w')

            lines = getSingleLines(layer)
            for line in lines:
                pointS = line[0]
                pointT = line[1]            
                sx = round(pointS.x(),numDigit)
                sy = round(pointS.y(),numDigit)
                tx = round(pointT.x(),numDigit)
                ty = round(pointT.y(),numDigit)
                fileS.write(str(sx) + " " + str(sy)+'\n')
                fileT.write(str(tx) + " " + str(ty)+'\n')
            
            fileS.close()
            fileT.close()
            
    def loadValidation(self, layer):        
        if layer:
            field_index = layer.fields().indexFromName('quality')
            if (field_index == -1):
                if self.debug:
                    QgsMessageLog.logMessage("The field 'quality' doesn't exist. Adding...", "OSM_SAA")
                res = layer.dataProvider().addAttributes([QgsField("quality", QVariant.String)])
                layer.updateFields()
            self.updateRadioButton()
                  
    def clickOnRadioButton(self):
        choice = ''
        if self.dockwidget.radioButton_1.isChecked():
            choice = 'null'
        elif self.dockwidget.radioButton_2.isChecked():
            choice = 'correct'
        elif self.dockwidget.radioButton_3.isChecked():
            choice = 'wrong'
        elif self.dockwidget.radioButton_4.isChecked():
            choice = 'uncertain'
        else:
            choice = 'null'
        
        field_index = self.currentLayer3.fields().indexFromName('quality')
        if (field_index != -1):
            self.currentLayer3.dataProvider().changeAttributeValues({ self.currentID : {field_index: choice}})
            
    def creaLayer(self, fullFileName, type):
  
        if not os.path.exists(fullFileName):
            fields = QgsFields()
            fields.append(QgsField("ID", QVariant.Int))
            fields.append(QgsField("value", QVariant.Double))
            crs = QgsCoordinateReferenceSystem("EPSG:3857")
            writer = QgsVectorFileWriter(fullFileName, "UTF-8", fields, type, crs, "ESRI Shapefile")
            del writer
            
            name = os.path.basename(fullFileName)
            nameWithoutExt = os.path.splitext(name)[0]
                             
            layer = QgsVectorLayer(fullFileName, nameWithoutExt, "ogr")
            QgsProject.instance().addMapLayer(layer)
        else:
            layer = None
            QMessageBox.critical(None, "ERROR", "File: " + fullFileName + " already exists!")

        return layer
                          
    def changedComboBoxLayer1(self):
        indexLayer1 = self.dockwidget.comboBox_Layer1.currentIndex()
        if (indexLayer1 >= 0):
            self.currentLayer1 = self.dockwidget.comboBox_Layer1.itemData(indexLayer1)
            self.updateDependentComboBox(self.dockwidget.comboBox_Layer2, self.dockwidget.comboBox_Layer1, self.dockwidget.button_LockLayer2, QgsWkbTypes.PolygonGeometry, self.currentLayer2)
        else:
            self.currentLayer1 = None
 
    def changedComboBoxLayer2(self):
        indexLayer2 = self.dockwidget.comboBox_Layer2.currentIndex()
        if (indexLayer2 >= 0):
            self.currentLayer2 = self.dockwidget.comboBox_Layer2.itemData(indexLayer2)
        else:
            self.currentLayer2 = None

            
    def changedComboBoxLayer3(self):
        indexLayer3 = self.dockwidget.comboBox_Layer3.currentIndex()
        if (indexLayer3 >= 0):
            self.currentLayer3 = self.dockwidget.comboBox_Layer3.itemData(indexLayer3)
        else:
            self.currentLayer3 = None
    
    def layersAdded(self, layers):
        self.updateAllComboBox()

    def layersWillBeRemoved(self, layerIds):
        for id in layerIds:
            if self.currentLayer1 and id == self.currentLayer1.id():
                self.currentLayer1 = None
                self.lockedLayer1 = False
                
            if self.currentLayer2 and id == self.currentLayer2.id():
                self.currentLayer2 = None
                self.lockedLayer2 = False
                self.dockwidget.button_DownloadLayer2.setEnabled(True)
                
            if self.currentLayer3 and id == self.currentLayer3.id():
                self.currentLayer3 = None
                self.lockedLayer3 = False
                self.dockwidget.button_CreateLayer3.setEnabled(True)
                
            if self.resultLayer and id == self.resultLayer.id():
                self.resultLayer = None
                
            if self.resultTable and id == self.resultTable.id():
                self.resultTable = None

    def layersRemoved(self, layerIds):                
        self.updateAllComboBox()
     
    def updateAllComboBox(self):
        self.updateComboBox(self.dockwidget.comboBox_Layer1, self.dockwidget.button_LockLayer1, QgsWkbTypes.PolygonGeometry, self.currentLayer1)
        self.updateDependentComboBox(self.dockwidget.comboBox_Layer2, self.dockwidget.comboBox_Layer1, self.dockwidget.button_LockLayer2, QgsWkbTypes.PolygonGeometry, self.currentLayer2)
        self.updateComboBox(self.dockwidget.comboBox_Layer3, self.dockwidget.button_LockLayer3, QgsWkbTypes.LineGeometry, self.currentLayer3)
    
    def updateDependentComboBox(self, combobox, combobox2, button, geomType, currentLayer):

        combobox.blockSignals(True)
        
        combobox.clear()
        
        if combobox2.count() > 0:
            index = combobox2.currentIndex()
            alreadySelectedLayer = combobox2.itemData(index)
        else:
            alreadySelectedLayer = None
            
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if (layer.type() == QgsMapLayer.VectorLayer):
                if (layer.geometryType() == geomType):
                    if (layer != alreadySelectedLayer):
                        combobox.addItem(layer.name(),layer)
        
        if currentLayer:
            index = combobox.findData(currentLayer)
            if index >= 0:
                combobox.setCurrentIndex(index)
        else:
            button.setEnabled(True)
            button.setChecked(False)
            button.setIcon(self.icon_unlock)
            combobox.setEnabled(True)
        
        if combobox.count() == 0:
            button.setEnabled(False)
            button.setChecked(False)
            combobox.setEnabled(False)
        else:
            button.setEnabled(True)
        
        combobox.blockSignals(False)
    
    def updateComboBox(self, combobox, button, geomType, currentLayer):

        combobox.blockSignals(True)
        
        combobox.clear()
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            if (layer.type() == QgsMapLayer.VectorLayer):
                if (layer.geometryType() == geomType):
                    combobox.addItem(layer.name(),layer)
        
        if currentLayer:
            index = combobox.findData(currentLayer)
            if index >= 0:
                combobox.setCurrentIndex(index)
        else:
            button.setEnabled(True)
            button.setChecked(False)
            button.setIcon(self.icon_unlock)
            combobox.setEnabled(True)
        
        if combobox.count() == 0:
            button.setEnabled(False)
            button.setChecked(False)
            combobox.setEnabled(False)
        else:
            button.setEnabled(True)
        
        combobox.blockSignals(False)
        
    def getGeometryTypeAsString(self, type):
        if type == QgsWkbTypes.PointGeometry:
            return "Point"
        elif type == QgsWkbTypes.LineGeometry:
            return "LineString"
        elif type == QgsWkbTypes.PolygonGeometry:
            return "Polygon"
        elif type == QgsWkbTypes.NullGeometry:
            return "NullGeometry"
        elif type == QgsWkbTypes.UnknownGeometry:
            return "UnknownGeometry"
        else:
            return "Wrong geometry type code"
    
